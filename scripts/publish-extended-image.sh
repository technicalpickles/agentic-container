#!/usr/bin/env bash

# publish-extended-image.sh - Automate building and publishing extended images
# This script helps create, build, and publish customized images based on agentic-container

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_REGISTRY="${BASE_REGISTRY:-ghcr.io/technicalpickles/agentic-container}"

show_help() {
    cat << EOF
publish-extended-image.sh - Automate building and publishing extended images

USAGE:
    publish-extended-image.sh [OPTIONS] BASE_IMAGE TARGET_REGISTRY/IMAGE:TAG

DESCRIPTION:
    Creates a custom Dockerfile extending the specified base image, builds it,
    and publishes it to a container registry. This enables automated creation
    of specialized development environments.

ARGUMENTS:
    BASE_IMAGE              Base image to extend (base, tools, ruby, node, python, go, dev)
    TARGET_REGISTRY/IMAGE   Full image name including registry and tag

OPTIONS:
    -l, --language LANG     Add language runtime (can be used multiple times)
    -t, --tool TOOL         Add development tool (can be used multiple times)  
    -p, --package PKG       Add system package (can be used multiple times)
    -f, --dockerfile FILE   Use custom Dockerfile instead of generating one
    --template TEMPLATE     Use a predefined template (python-ml, fullstack-web)
    --platforms PLATFORMS   Target platforms for build (default: linux/amd64,linux/arm64)
    --push                  Push the image after building (default: false)
    --latest                Also tag as 'latest' (default: false)
    --dry-run               Show what would be done without executing
    -h, --help              Show this help message

EXAMPLES:
    # Create and publish a Python ML development environment
    publish-extended-image.sh \\
        --template python-ml \\
        --push \\
        python \\
        ghcr.io/myorg/python-ml-dev:v1.0.0

    # Create a custom Ruby environment with additional tools
    publish-extended-image.sh \\
        --language ruby@3.2 \\
        --tool gh \\
        --tool kubectl \\
        --package postgresql-client \\
        --push \\
        base \\
        ghcr.io/myorg/ruby-devops:latest

    # Use a custom Dockerfile
    publish-extended-image.sh \\
        --dockerfile ./custom/Dockerfile \\
        --push \\
        tools \\
        ghcr.io/myorg/my-custom-env:v2.1.0

ENVIRONMENT VARIABLES:
    BASE_REGISTRY           Registry for base images (default: ghcr.io/technicalpickles/agentic-container)
    DOCKER_BUILDKIT         Enable BuildKit features (default: 1)

EOF
}

# Parse command line arguments
LANGUAGES=()
TOOLS=()
PACKAGES=()
CUSTOM_DOCKERFILE=""
TEMPLATE=""
PLATFORMS="linux/amd64,linux/arm64"
PUSH=false
LATEST=false
DRY_RUN=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -l|--language)
            LANGUAGES+=("$2")
            shift 2
            ;;
        -t|--tool)
            TOOLS+=("$2")
            shift 2
            ;;
        -p|--package)
            PACKAGES+=("$2")
            shift 2
            ;;
        -f|--dockerfile)
            CUSTOM_DOCKERFILE="$2"
            shift 2
            ;;
        --template)
            TEMPLATE="$2"
            shift 2
            ;;
        --platforms)
            PLATFORMS="$2"
            shift 2
            ;;
        --push)
            PUSH=true
            shift
            ;;
        --latest)
            LATEST=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "ERROR: Unknown option $1" >&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

if [[ $# -lt 2 ]]; then
    echo "ERROR: BASE_IMAGE and TARGET_REGISTRY/IMAGE:TAG are required" >&2
    echo "Run '$0 --help' for usage information." >&2
    exit 1
fi

BASE_IMAGE="$1"
TARGET_IMAGE="$2"

# Extract image name without tag for 'latest' tagging
TARGET_IMAGE_BASE="${TARGET_IMAGE%:*}"
TARGET_TAG="${TARGET_IMAGE##*:}"

generate_dockerfile() {
    local dockerfile="$1"
    local base_image="$2"
    
    cat > "$dockerfile" << EOF
# Extended development container
# Generated by publish-extended-image.sh
# Base: $BASE_REGISTRY:$base_image

FROM $BASE_REGISTRY:$base_image

EOF

    if [[ ${#PACKAGES[@]} -gt 0 ]]; then
        cat >> "$dockerfile" << EOF
# Install additional system packages
USER root
RUN apt-get update && apt-get install -y \\
EOF
        for pkg in "${PACKAGES[@]}"; do
            echo "    $pkg \\" >> "$dockerfile"
        done
        cat >> "$dockerfile" << EOF
    && rm -rf /var/lib/apt/lists/*

USER \$USERNAME

EOF
    fi

    if [[ ${#LANGUAGES[@]} -gt 0 || ${#TOOLS[@]} -gt 0 ]]; then
        cat >> "$dockerfile" << EOF
# Install additional languages and tools via mise
EOF
        for lang in "${LANGUAGES[@]}"; do
            echo "RUN mise install $lang && mise use -g $lang" >> "$dockerfile"
        done
        
        for tool in "${TOOLS[@]}"; do
            echo "RUN mise install $tool" >> "$dockerfile"
        done
        
        echo "" >> "$dockerfile"
    fi

    cat >> "$dockerfile" << EOF
# Set working directory
WORKDIR /workspace

# Default command
CMD ["/bin/bash", "--login"]
EOF
}

main() {
    local dockerfile_path="Dockerfile.extended"
    local temp_dockerfile=false
    
    if [[ "$DRY_RUN" == true ]]; then
        echo "üèÉ DRY RUN MODE - Commands that would be executed:"
        echo ""
    fi
    
    # Determine which Dockerfile to use
    if [[ -n "$CUSTOM_DOCKERFILE" ]]; then
        if [[ ! -f "$CUSTOM_DOCKERFILE" ]]; then
            echo "ERROR: Custom Dockerfile not found: $CUSTOM_DOCKERFILE" >&2
            exit 1
        fi
        dockerfile_path="$CUSTOM_DOCKERFILE"
        echo "üìÑ Using custom Dockerfile: $dockerfile_path"
    elif [[ -n "$TEMPLATE" ]]; then
        local template_path="$SCRIPT_DIR/../templates/Dockerfile.$TEMPLATE"
        if [[ ! -f "$template_path" ]]; then
            echo "ERROR: Template not found: $template_path" >&2
            exit 1
        fi
        dockerfile_path="$template_path"
        echo "üìã Using template: $TEMPLATE"
    else
        echo "üèóÔ∏è  Generating Dockerfile extending $BASE_REGISTRY:$BASE_IMAGE"
        generate_dockerfile "$dockerfile_path" "$BASE_IMAGE"
        temp_dockerfile=true
        echo "üìÑ Generated: $dockerfile_path"
    fi
    
    # Show what will be built
    echo "üéØ Target image: $TARGET_IMAGE"
    if [[ "$LATEST" == true ]]; then
        echo "üè∑Ô∏è  Will also tag as: $TARGET_IMAGE_BASE:latest"
    fi
    echo "üèóÔ∏è  Platforms: $PLATFORMS"
    
    if [[ "$DRY_RUN" == true ]]; then
        echo ""
        echo "Dockerfile content:"
        echo "===================="
        cat "$dockerfile_path"
        echo "===================="
        echo ""
        echo "Would execute:"
        if command -v gh >/dev/null 2>&1 && gh auth status >/dev/null 2>&1; then
            echo "docker buildx build --platform $PLATFORMS -t $TARGET_IMAGE -f $dockerfile_path --secret id=github_token,src=<(gh auth token) ."
        else
            echo "docker buildx build --platform $PLATFORMS -t $TARGET_IMAGE -f $dockerfile_path ."
        fi
        if [[ "$LATEST" == true ]]; then
            echo "docker tag $TARGET_IMAGE $TARGET_IMAGE_BASE:latest"
        fi
        if [[ "$PUSH" == true ]]; then
            echo "docker push $TARGET_IMAGE"
            if [[ "$LATEST" == true ]]; then
                echo "docker push $TARGET_IMAGE_BASE:latest"
            fi
        fi
        return 0
    fi
    
    # Build the image
    export DOCKER_BUILDKIT=1
    echo "üèóÔ∏è  Building image..."
    
    # Check if GitHub CLI is available for token access
    if command -v gh >/dev/null 2>&1 && gh auth status >/dev/null 2>&1; then
        echo "üîê Using GitHub token via secret mounting to avoid API rate limits"
        docker buildx build \
            --platform "$PLATFORMS" \
            -t "$TARGET_IMAGE" \
            -f "$dockerfile_path" \
            --secret id=github_token,src=<(gh auth token) \
            .
    else
        echo "‚ö†Ô∏è  No GitHub token available, may hit API rate limits"
        docker buildx build \
            --platform "$PLATFORMS" \
            -t "$TARGET_IMAGE" \
            -f "$dockerfile_path" \
            .
    fi
    
    # Tag as latest if requested
    if [[ "$LATEST" == true ]]; then
        echo "üè∑Ô∏è  Tagging as latest..."
        docker tag "$TARGET_IMAGE" "$TARGET_IMAGE_BASE:latest"
    fi
    
    # Push if requested
    if [[ "$PUSH" == true ]]; then
        echo "üì§ Pushing image..."
        docker push "$TARGET_IMAGE"
        
        if [[ "$LATEST" == true ]]; then
            echo "üì§ Pushing latest tag..."
            docker push "$TARGET_IMAGE_BASE:latest"
        fi
    fi
    
    # Cleanup temporary Dockerfile
    if [[ "$temp_dockerfile" == true ]]; then
        rm -f "$dockerfile_path"
    fi
    
    echo "‚úÖ Complete! Image built: $TARGET_IMAGE"
    if [[ "$PUSH" == true ]]; then
        echo "üöÄ Image published and ready to use!"
    else
        echo "üí° Run with --push to publish to registry"
    fi
}

main "$@"
